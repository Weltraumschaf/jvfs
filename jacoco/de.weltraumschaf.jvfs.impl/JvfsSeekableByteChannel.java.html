<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JvfsSeekableByteChannel.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JVFS</a> &gt; <a href="index.html" class="el_package">de.weltraumschaf.jvfs.impl</a> &gt; <span class="el_source">JvfsSeekableByteChannel.java</span></div><h1>JvfsSeekableByteChannel.java</h1><pre class="source lang-java linenums">/*
 * JBoss, Home of Professional Open Source
 * Copyright 2012, Red Hat Middleware LLC, and individual contributors
 * by the @authors tag. See the copyright.txt in the distribution for a
 * full listing of individual contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.weltraumschaf.jvfs.impl;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.SeekableByteChannel;

/**
 * {@link SeekableByteChannel} implementation backed by an auto-resizing byte array; thread-safe.
 *
 * Can hold a maxiumum of {@link Integer#MAX_VALUE} bytes.
 *
 * @author &lt;a href=&quot;mailto:alr@jboss.org&quot;&gt;Andrew Lee Rubinger&lt;/a&gt;
 */
<span class="pc bpc" id="L33" title="1 of 2 branches missed.">class JvfsSeekableByteChannel implements SeekableByteChannel {</span>

    /**
     * Current position; guarded by &quot;this&quot;.
     */
    private int position;

    /**
     * Whether or not this {@link SeekableByteChannel} is open; volatile instead of sync is acceptable because this
     * field participates in no compound computations or invariants with other instance members.
     */
    private volatile boolean open;

    /**
     * Internal buffer for contents; guarded by &quot;this&quot;.
     */
    private byte[] contents;
    /**
     * Associated file entry.
     */
    private final JvfsFileEntry entry;

    /**
     * Dedicated constructor.
     *
     * @param entry must not be {@code null}
     */
    JvfsSeekableByteChannel(final JvfsFileEntry entry) {
<span class="fc" id="L61">        super();</span>
<span class="pc bpc" id="L62" title="2 of 4 branches missed.">        assert null != entry : &quot;entry must be defined&quot;;</span>
<span class="fc" id="L63">        this.open = true;</span>

        // Set fields
<span class="fc" id="L66">        synchronized (this) {</span>
<span class="fc" id="L67">            this.position = 0;</span>
<span class="fc" id="L68">            this.contents = entry.getContent();</span>
<span class="fc" id="L69">            this.entry = entry;</span>
<span class="pc" id="L70">        }</span>
<span class="fc" id="L71">    }</span>

    @Override
    public boolean isOpen() {
<span class="fc" id="L75">        return this.open;</span>
    }

    @Override
    public void close() throws IOException {
<span class="fc" id="L80">        this.open = false;</span>
<span class="fc" id="L81">    }</span>

    @Override
    public int read(final ByteBuffer destination) throws IOException {
<span class="fc" id="L85">        this.checkClosed();</span>

<span class="fc bfc" id="L87" title="All 2 branches covered.">        if (destination == null) {</span>
<span class="fc" id="L88">            throw new IllegalArgumentException(&quot;Destination buffer must be supplied&quot;);</span>
        }

        // Init
<span class="fc" id="L92">        final int spaceInBuffer = destination.remaining();</span>
        final int numBytesRemainingInContent;
        final int numBytesToRead;

        // Sync up before getting at shared mutable state
<span class="fc" id="L97">        synchronized (this) {</span>
<span class="fc" id="L98">            entry.beginRead();</span>
<span class="fc" id="L99">            numBytesRemainingInContent = this.contents.length - this.position;</span>

            // Set position was greater than the size? Just return.
<span class="fc bfc" id="L102" title="All 2 branches covered.">            if (numBytesRemainingInContent &lt;= 0) {</span>
<span class="fc" id="L103">                return -1;</span>
            }

            // We'll read in either the number of bytes remaining in content or the amount of space in the buffer,
            // whichever is smaller
<span class="fc bfc" id="L108" title="All 2 branches covered.">            numBytesToRead = numBytesRemainingInContent &gt;= spaceInBuffer ? spaceInBuffer : numBytesRemainingInContent;</span>
            // Copy a sub-array of the bytes we'll put into the buffer
<span class="fc" id="L110">            destination.put(this.contents, this.position, numBytesToRead);</span>

            // Set the new position
<span class="fc" id="L113">            this.position += numBytesToRead;</span>
<span class="fc" id="L114">            entry.endRead();</span>
<span class="pc" id="L115">        }</span>

        // Return the number of bytes read
<span class="fc" id="L118">        return numBytesToRead;</span>
    }

    @Override
    public int write(final ByteBuffer source) throws IOException {
<span class="fc" id="L123">        this.checkClosed();</span>

<span class="fc bfc" id="L125" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L126">            throw new IllegalArgumentException(&quot;Source buffer must be supplied&quot;);</span>
        }

        // Put the bytes to be written into a byte[]
<span class="fc" id="L130">        final int totalBytes = source.remaining();</span>
<span class="fc" id="L131">        final byte[] readContents = new byte[totalBytes];</span>
<span class="fc" id="L132">        source.get(readContents);</span>

        // Sync up, we're gonna access shared mutable state.
<span class="fc" id="L135">        synchronized (this) {</span>
<span class="fc" id="L136">            entry.beginWrite();</span>
            // Append the read contents to our internal contents.
<span class="fc" id="L138">            this.contents = this.concat(this.contents, readContents, this.position);</span>
            // Increment the position of this channel.
<span class="fc" id="L140">            this.position += totalBytes;</span>
<span class="fc" id="L141">            entry.setContent(contents);</span>
<span class="fc" id="L142">            entry.endWrite();</span>
<span class="pc" id="L143">        }</span>

        // Return the number of bytes read.
<span class="fc" id="L146">        return totalBytes;</span>
    }

    /**
     * Creates a new array which is the concatenated result of the two inputs, at the designated position (to be filled
     * with 0x00) in the case of a gap).
     *
     * @param input1 must not be null
     * @param input2 must not be null
     * @param pos non negative number
     * @return never null
     */
    private byte[] concat(final byte[] input1, final byte[] input2, final int pos) {
        // Preconition checks
<span class="pc bpc" id="L160" title="2 of 4 branches missed.">        assert input1 != null : &quot;Input 1 must be specified&quot;;</span>
<span class="pc bpc" id="L161" title="2 of 4 branches missed.">        assert input2 != null : &quot;Input 2 must be specified&quot;;</span>
<span class="pc bpc" id="L162" title="2 of 4 branches missed.">        assert pos &gt;= 0 : &quot;Position must be 0 or higher&quot;;</span>
        // Allocate a new array of enough space (either current size or position + input2.length, whichever is greater)
<span class="fc bfc" id="L164" title="All 2 branches covered.">        final int newSize = pos &lt; input1.length ? input1.length + input2.length : pos + input2.length;</span>
<span class="fc" id="L165">        final byte[] merged = new byte[newSize];</span>
        // Copy in the contents of input 1 with 0 offset
<span class="fc" id="L167">        System.arraycopy(input1, 0, merged, 0, input1.length);</span>
        // Copy in the contents of input2 with offset the length of input 1
<span class="fc" id="L169">        System.arraycopy(input2, 0, merged, pos, input2.length);</span>
<span class="fc" id="L170">        return merged;</span>
    }

    @Override
    public long position() throws IOException {
<span class="fc" id="L175">        synchronized (this) {</span>
<span class="fc" id="L176">            return this.position;</span>
<span class="nc" id="L177">        }</span>
    }

    @Override
    public SeekableByteChannel position(final long newPosition) throws IOException {
        // Precondition checks
<span class="fc bfc" id="L183" title="All 4 branches covered.">        if (newPosition &gt; Integer.MAX_VALUE || newPosition &lt; 0) {</span>
<span class="fc" id="L184">            throw new IllegalArgumentException(&quot;Valid position for this channel is between 0 and &quot; + Integer.MAX_VALUE);</span>
        }

<span class="fc" id="L187">        synchronized (this) {</span>
<span class="fc" id="L188">            this.position = (int) newPosition;</span>
<span class="pc" id="L189">        }</span>

<span class="fc" id="L191">        return this;</span>
    }

    @Override
    public long size() throws IOException {
<span class="fc" id="L196">        synchronized (this) {</span>
<span class="fc" id="L197">            return this.contents.length;</span>
<span class="nc" id="L198">        }</span>
    }

    @Override
    public SeekableByteChannel truncate(final long size) throws IOException {
        // Precondition checks
<span class="fc bfc" id="L204" title="All 4 branches covered.">        if (size &lt; 0 || size &gt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L205">            throw new IllegalArgumentException(&quot;This implementation permits a size of 0 to &quot; + Integer.MAX_VALUE</span>
                    + &quot; inclusive&quot;);
        }

        // Sync up for mucking w/ shared mutable state
<span class="fc" id="L210">        synchronized (this) {</span>
<span class="fc" id="L211">            final int newSize = (int) size;</span>
<span class="fc" id="L212">            final int currentSize = (int) this.size();</span>

            // If the current position is greater than the given size, set to the given size (by API spec)
<span class="fc bfc" id="L215" title="All 2 branches covered.">            if (this.position &gt; newSize) {</span>
<span class="fc" id="L216">                this.position = newSize;</span>
            }

            // If we've been given a size smaller than we currently are
<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (currentSize &gt; newSize) {</span>
                // Make new array
<span class="fc" id="L222">                final byte[] newContents = new byte[newSize];</span>
                // Copy in the contents up to the new size
<span class="fc" id="L224">                System.arraycopy(this.contents, 0, newContents, 0, newSize);</span>
                // Set the new array as our contents
<span class="fc" id="L226">                this.contents = newContents;</span>
            }

            // If we've been given a size greater than we are
<span class="fc bfc" id="L230" title="All 2 branches covered.">            if (newSize &gt; currentSize) {</span>
                // Reset the position only
<span class="fc" id="L232">                this.position = newSize;</span>
            }
<span class="pc" id="L234">        }</span>

        // Return this reference
<span class="fc" id="L237">        return this;</span>
    }

    /**
     * Get the bytes as input stream.
     *
     * @return never {@code null}
     */
    InputStream getContents() {
        final byte[] copy;

<span class="fc" id="L248">        synchronized (this) {</span>
<span class="fc" id="L249">            final int length = this.contents.length;</span>
<span class="fc" id="L250">            copy = new byte[length];</span>
<span class="fc" id="L251">            System.arraycopy(this.contents, 0, copy, 0, this.contents.length);</span>
<span class="pc" id="L252">        }</span>

<span class="fc" id="L254">        return new ByteArrayInputStream(copy);</span>
    }

    /**
     * Checks if closed.
     *
     * @throws ClosedChannelException if not open
     */
    private void checkClosed() throws ClosedChannelException {
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (!this.isOpen()) {</span>
<span class="fc" id="L264">            throw new ClosedChannelException();</span>
        }
<span class="fc" id="L266">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.3.201306030806</span></div></body></html>