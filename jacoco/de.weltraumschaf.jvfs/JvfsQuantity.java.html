<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JvfsQuantity.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JVFS</a> &gt; <a href="index.html" class="el_package">de.weltraumschaf.jvfs</a> &gt; <span class="el_source">JvfsQuantity.java</span></div><h1>JvfsQuantity.java</h1><pre class="source lang-java linenums">/*
 *  LICENSE
 *
 * &quot;THE BEER-WARE LICENSE&quot; (Revision 43):
 * &quot;Sven Strittmatter&quot; &lt;weltraumschaf@googlemail.com&gt; wrote this file.
 * As long as you retain this notice you can do whatever you want with
 * this stuff. If we meet some day, and you think this stuff is worth it,
 * you can buy me a non alcohol-free beer in return.
 *
 * Copyright (C) 2012 &quot;Sven Strittmatter&quot; &lt;weltraumschaf@googlemail.com&gt;
 */

package de.weltraumschaf.jvfs;

import java.util.Map;

/**
 * Abstracts the quantity a file or a file system may have in bytes.
 *
 * @author Sven Strittmatter &lt;weltraumschaf@googlemail.com&gt;
 */
<span class="pc bpc" id="L22" title="1 of 2 branches missed.">public final class JvfsQuantity {</span>

    /**
     * Quantity with size 0.
     */
<span class="fc" id="L27">    public static final JvfsQuantity EMPTY = new JvfsQuantity(0L);</span>
    /**
     * Factor for magnitudes.
     */
    private static final long FACTOR = 1024L;
    /**
     * Caches instances by its string representation.
     */
<span class="fc" id="L35">    private static final Map&lt;String, JvfsQuantity&gt; CACHE_BY_STRING = JvfsCollections.newMap();</span>
    /**
     * Caches instances by its value.
     */
<span class="fc" id="L39">    private static final Map&lt;Long, JvfsQuantity&gt; CACHE_BY_LONG = JvfsCollections.newMap();</span>
    /**
     * Number of bytes.
     */
    private final long value;

    /**
     * Dedicated constructor.
     *
     * Use {@link #forValue(java.lang.String)} or {@link #forValue(long)} to get instances.
     *
     * @param value must not be negative
     */
    private JvfsQuantity(final long value) {
<span class="fc" id="L53">        super();</span>
<span class="pc bpc" id="L54" title="2 of 4 branches missed.">        assert value &gt;= 0 : &quot;value must not be negative&quot;;</span>
<span class="fc" id="L55">        this.value = value;</span>
<span class="fc" id="L56">    }</span>

    /**
     * Get the number of bytes.
     *
     * @return non negative
     */
    public long value() {
<span class="fc" id="L64">        return value;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L69">        return (int) value;</span>
    }

    @Override
    public boolean equals(final Object obj) {
<span class="fc bfc" id="L74" title="All 2 branches covered.">        if (!(obj instanceof JvfsQuantity)) {</span>
<span class="fc" id="L75">            return false;</span>
        }

<span class="fc" id="L78">        final JvfsQuantity other = (JvfsQuantity) obj;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">        return value == other.value;</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L84">        return String.valueOf(value);</span>
    }

    /**
     * Factory method to get instances by a string representation.
     *
     * The string representation is either a number (the bytes) or
     * a number an a letter for magnitudes:
     * &lt;ul&gt;
     * &lt;li&gt;&lt;kbd&gt;k&lt;/kbd&gt; or &lt;kbd&gt;K&lt;/kbd&gt; for kilo&lt;/li&gt;
     * &lt;li&gt;&lt;kbd&gt;m&lt;/kbd&gt; or &lt;kbd&gt;M&lt;/kbd&gt; for mega&lt;/li&gt;
     * &lt;li&gt;&lt;kbd&gt;g&lt;/kbd&gt; or &lt;kbd&gt;G&lt;/kbd&gt; for giga&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * This method caches instances and returns the same for the same input value.
     *
     * @param quantity must not be {@literal null} or empty
     * @return never {@literal null}
     */
    public static JvfsQuantity forValue(final String quantity) {
<span class="fc" id="L104">        JvfsAssertions.notNull(quantity, &quot;quantity&quot;);</span>
<span class="fc" id="L105">        final String trimmedQuantity = quantity.trim();</span>
<span class="fc" id="L106">        JvfsAssertions.notEmpty(trimmedQuantity, &quot;quantity&quot;);</span>

<span class="fc bfc" id="L108" title="All 2 branches covered.">        if (!CACHE_BY_STRING.containsKey(trimmedQuantity)) {</span>
<span class="fc" id="L109">            CACHE_BY_STRING.put(trimmedQuantity, forValue(parseQuantity(trimmedQuantity)));</span>
        }

<span class="fc" id="L112">        return CACHE_BY_STRING.get(trimmedQuantity);</span>
    }

    /**
     * Factory method to get instances by number of bytes.
     *
     * This method caches instances and returns the same for the same input value.
     *
     * @param quantity must not be negative
     * @return never {@literal null}
     */
    public static JvfsQuantity forValue(final long quantity) {
<span class="fc" id="L124">        JvfsAssertions.greaterThanEqual(quantity, 0, &quot;quantity&quot;);</span>

<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (!CACHE_BY_LONG.containsKey(quantity)) {</span>
<span class="fc" id="L127">            CACHE_BY_LONG.put(quantity, new JvfsQuantity(quantity));</span>
        }

<span class="fc" id="L130">        return CACHE_BY_LONG.get(quantity);</span>
    }

    /**
     * Parses string to long with respecting magnitudes ('k', 'K', 'm', 'M', &quot;g', 'G').
     *
     * @param quantity must not be {@literal null} or empty
     * @return any long
     */
    static long parseQuantity(final String quantity) {
<span class="fc" id="L140">        JvfsAssertions.notNull(quantity, &quot;quantity&quot;);</span>
<span class="fc" id="L141">        final String trimmedQuantity = quantity.trim();</span>
<span class="fc" id="L142">        JvfsAssertions.notEmpty(trimmedQuantity, &quot;quantity&quot;);</span>

<span class="fc" id="L144">        final char last = trimmedQuantity.toLowerCase().charAt(trimmedQuantity.length() - 1);</span>
<span class="fc" id="L145">        final Magnitude factor = Magnitude.forValue(last);</span>
        final String stringValue;

<span class="fc bfc" id="L148" title="All 2 branches covered.">        if (factor == Magnitude.NONE) {</span>
<span class="fc" id="L149">            stringValue = trimmedQuantity;</span>
        } else {
<span class="fc" id="L151">            stringValue = trimmedQuantity.substring(0, trimmedQuantity.length() - 1);</span>
        }

<span class="fc" id="L154">        final long base = Long.parseLong(stringValue);</span>
<span class="fc" id="L155">        return base * factor.factor;</span>
    }

    /**
     * Magnitudes of bytes.
     */
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">    private enum Magnitude {</span>
        /**
         * Magnitude of factor 2^1.
         */
<span class="fc" id="L165">        NONE(' ', 1),</span>
        /**
         * Magnitude kilo ('k') of factor 2^10 (1024).
         */
<span class="fc" id="L169">        KILO('k', FACTOR),</span>
        /**
         * Magnitude mega ('m') of factor 2^20 (1048576).
         */
<span class="fc" id="L173">        MEGA('m', FACTOR * FACTOR),</span>
        /**
         * Magnitude giga ('g') of factor 2^30 (1073741824).
         */
<span class="fc" id="L177">        GIGA('g', FACTOR * FACTOR * FACTOR);</span>

        /**
         * The nornmalized (lower case) meta character.
         */
        private final char meta;
        /**
         * Concrete factor.
         */
        private final long factor;

        /**
         * Dedicated constructor.
         *
         * @param meta any character
         * @param factor must not be less than one
         */
<span class="fc" id="L194">        private Magnitude(final char meta, final long factor) {</span>
<span class="pc bpc" id="L195" title="2 of 4 branches missed.">            assert factor &gt; 0 : &quot;factor must be greater than 0&quot;;</span>
<span class="fc" id="L196">            this.meta = meta;</span>
<span class="fc" id="L197">            this.factor = factor;</span>
<span class="fc" id="L198">        }</span>

        /**
         * Finds the proper magnitude for a given meta character.
         *
         * If the character is not a valid meta character {@link #NONE} is returned.
         *
         * @param meta any character
         * @return never {@literal null}, as default {@link #NONE}
         */
        static Magnitude forValue(final char meta) {
<span class="fc bfc" id="L209" title="All 2 branches covered.">            for (final Magnitude f : values()) {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                if (f.meta == meta) {</span>
<span class="fc" id="L211">                    return f;</span>
                }
            }

<span class="fc" id="L215">            return NONE;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.3.201306030806</span></div></body></html>